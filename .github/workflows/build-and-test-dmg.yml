name: Build & Test macOS DMG

on:
  workflow_dispatch:
    inputs:
      installer_url:
        description: "HTTPS URL to .zip/.dmg/.pkg/.app (nested zips OK). If empty, uses INSTALLER_URL secret."
        required: false

jobs:
  build-dmg:
    runs-on: macos-15
    steps:
      - name: Resolve URL
        id: url
        run: |
          if [ -n "${{ github.event.inputs.installer_url }}" ]; then
            echo "url=${{ github.event.inputs.installer_url }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ secrets.INSTALLER_URL }}" ]; then
            echo "url=${{ secrets.INSTALLER_URL }}" >> $GITHUB_OUTPUT
          else
            echo "No URL provided (input or INSTALLER_URL secret)."; exit 1
          fi

      - name: Download artifact
        run: |
          set -euxo pipefail
          curl -L "${{ steps.url.outputs.url }}" -o artifact.bin
          file artifact.bin | tee filetype.txt

      - name: Extract/locate installer (.app/.pkg/.dmg); repair APP.bundle if needed
        id: find
        run: |
          set -euxo pipefail
          ROOT="$PWD/work"
          rm -rf "$ROOT" && mkdir -p "$ROOT"

          # Direct DMG?
          if hdiutil imageinfo artifact.bin >/dev/null 2>&1; then
            mv artifact.bin "$ROOT/in.dmg"
            echo "kind=dmg" >> $GITHUB_OUTPUT
            echo "path=$ROOT/in.dmg" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Direct PKG?
          if xar -tf artifact.bin >/dev/null 2>&1; then
            mv artifact.bin "$ROOT/in.pkg"
            echo "kind=pkg" >> $GITHUB_OUTPUT
            echo "path=$ROOT/in.pkg" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Treat as ZIP (with optional nesting up to 3 levels)
          UNZIP="$ROOT/unzipped"; mkdir -p "$UNZIP"
          if unzip -tq artifact.bin >/dev/null 2>&1; then
            unzip -q artifact.bin -d "$UNZIP"

            for i in 1 2 3; do
              # Prefer pkg/dmg files
              F=$(find "$UNZIP" -maxdepth 8 -type f \( -name "*.pkg" -o -name "*.dmg" \) | head -n1 || true)
              if [ -n "$F" ]; then
                case "$F" in
                  *.pkg) echo "kind=pkg" >> $GITHUB_OUTPUT ;;
                  *.dmg) echo "kind=dmg" >> $GITHUB_OUTPUT ;;
                esac
                echo "path=$F" >> $GITHUB_OUTPUT
                exit 0
              fi

              # Then app bundles (directories)
              APPDIR=$(find "$UNZIP" -maxdepth 8 -type d -name "*.app" | head -n1 || true)
              if [ -n "$APPDIR" ]; then
                echo "kind=app" >> $GITHUB_OUTPUT
                echo "path=$APPDIR" >> $GITHUB_OUTPUT
                exit 0
              fi

              # Some builds produce APP.bundle with an app layout → fix name/flags
              BUNDLEDIR=$(find "$UNZIP" -maxdepth 8 -type d -name "*.bundle" | head -n1 || true)
              if [ -n "$BUNDLEDIR" ]; then
                PLIST="$BUNDLEDIR/Contents/Info.plist"
                if [ -f "$PLIST" ]; then
                  /usr/libexec/PlistBuddy -c 'Set :CFBundlePackageType APPL' "$PLIST" || true
                fi
                if [ -d "$BUNDLEDIR/Contents/MacOS" ]; then
                  chmod +x "$BUNDLEDIR"/Contents/MacOS/* || true
                fi
                APPFIX="${BUNDLEDIR%.bundle}.app"
                mv "$BUNDLEDIR" "$APPFIX"
                echo "kind=app" >> $GITHUB_OUTPUT
                echo "path=$APPFIX" >> $GITHUB_OUTPUT
                exit 0
              fi

              # One more nested zip (but never unzip inside .app)
              NZIP=$(find "$UNZIP" -maxdepth 8 -type f -name "*.zip" ! -path "*/.app/*" | head -n1 || true)
              [ -z "$NZIP" ] && break
              NDIR="$UNZIP/nest_$i"; mkdir -p "$NDIR"
              unzip -q "$NZIP" -d "$NDIR"
              rm -f "$NZIP"
            done

            echo "Could not find .app/.pkg/.dmg in supplied archive."; exit 2
          fi

          echo "Unknown input format."; exit 2

      - name: If DMG input, extract .app from it
        if: steps.find.outputs.kind == 'dmg'
        id: from_dmg
        run: |
          set -euxo pipefail
          DMG="${{ steps.find.outputs.path }}"
          MNT="/Volumes/INAPP"
          hdiutil attach "$DMG" -mountpoint "$MNT" -nobrowse
          APP=$(find "$MNT" -maxdepth 1 -type d -name "*.app" -print -quit || true)
          [ -z "$APP" ] && { echo "No .app inside DMG"; find "$MNT" -maxdepth 2 -print; hdiutil detach "$MNT"; exit 3; }
          OUT="$PWD/extracted.app"
          cp -R "$APP" "$OUT"
          hdiutil detach "$MNT"
          echo "kind=app"   >> $GITHUB_OUTPUT
          echo "path=$OUT"  >> $GITHUB_OUTPUT

      - name: Normalize APP path output
        id: app_path
        run: |
          if [ "${{ steps.find.outputs.kind }}" = "app" ]; then
            echo "app=${{ steps.find.outputs.path }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.from_dmg.outputs.kind }}" = "app" ]; then
            echo "app=${{ steps.from_dmg.outputs.path }}" >> $GITHUB_OUTPUT
          else
            echo "app=" >> $GITHUB_OUTPUT
          fi

      - name: Build DMG from app (validates .app; fixes “…/Contents”)
        if: steps.app_path.outputs.app != ''
        run: |
          set -euxo pipefail
          APP="${{ steps.app_path.outputs.app }}"

          # If we were handed ".../Something.app/Contents", step back to the bundle root
          case "$APP" in
            */Contents) APP="$(dirname "$APP")" ;;
          esac

          # Must be a .app directory
          if [ ! -d "$APP" ] || [[ "$APP" != *.app ]]; then
            echo "Not a .app bundle: $APP"
            echo "Bundle tree (if any):"
            /usr/bin/find "$(dirname "$APP")" -maxdepth 2 -print || true
            exit 2
          fi

          APPNAME="$(basename "$APP")"
          STAGE="dmg-root"; VOL="Willow Kick Snare Installer"
          rm -rf "$STAGE" "Willow_Kick_Snare_Installer.dmg"
          mkdir -p "$STAGE"
          cp -R "$APP" "$STAGE/"
          ln -s /Applications "$STAGE/Applications"

          # ensure main executables are executable
          if [ -d "$STAGE/$APPNAME/Contents/MacOS" ]; then
            find "$STAGE/$APPNAME/Contents/MacOS" -type f -exec chmod +x {} \; || true
          fi

          hdiutil create -volname "$VOL" -srcfolder "$STAGE" -fs HFS+ -format UDZO "Willow_Kick_Snare_Installer.dmg"

      - name: Upload DMG (or original PKG if provided)
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: |
            Willow_Kick_Snare_Installer.dmg
            ${{ steps.find.outputs.kind == 'pkg' && steps.find.outputs.path || '' }}
          if-no-files-found: ignore

  test-dmg:
    needs: build-dmg
    runs-on: macos-15
    steps:
      - name: Download dist
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: If only a PKG was provided, install it
        id: maybe_pkg
        run: |
          set -euxo pipefail
          PKG=$(ls dist/*.pkg 2>/dev/null | head -n1 || true)
          if [ -n "$PKG" ]; then
            spctl --assess --type install -vv "$PKG" || true
            pkgutil --check-signature "$PKG" || true
            sudo installer -pkg "$PKG" -target / -verboseR | tee install.log
            pkgutil --pkgs | tee receipts.txt
            echo "done=pkg" >> $GITHUB_OUTPUT
          else
            echo "done=" >> $GITHUB_OUTPUT
          fi

      - name: Mount DMG and copy app → /Applications (robust)
        if: steps.maybe_pkg.outputs.done != 'pkg'
        run: |
          set -euxo pipefail
          DMG=$(ls dist/*.dmg 2>/dev/null | head -n1 || true)
          [ -z "$DMG" ] && { echo "No DMG to test"; exit 0; }

          MNT=/Volumes/APPTEST
          hdiutil attach "$DMG" -mountpoint "$MNT" -nobrowse

          # Find a top-level .app (don’t dive into inner folders)
          APP=$(find "$MNT" -maxdepth 1 -type d -name "*.app" -print -quit || true)
          if [ -z "$APP" ]; then
            echo "No .app at DMG root. Listing:"
            find "$MNT" -maxdepth 2 -print
            hdiutil detach "$MNT"
            exit 3
          fi

          sudo cp -R "$APP" /Applications/
          hdiutil detach "$MNT"

          APPNAME=$(basename "$APP")
          /usr/bin/codesign -dv --verbose=4 "/Applications/$APPNAME" 2>&1 | tee codesign.txt
          /usr/bin/spctl --assess --type execute -vv "/Applications/$APPNAME" 2>&1 | tee spctl.txt || true
          /usr/bin/auval -a || true

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        with:
          name: macos-install-logs
          path: |
            install.log
            receipts.txt
            codesign.txt
            spctl.txt
          if-no-files-found: ignore
